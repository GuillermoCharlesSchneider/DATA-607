---
title: "Final Project"
author: "GuillermoSchneider"
date: "2024-05-05"
output: html_document
---

*libraries*
```{r}
library(tidyverse)
library(ggplot2)
#install.packages('cowplot')
library(cowplot)
#install.packages('caret')
library(caret)
#install.packages("rpart.plot")
library(rpart.plot)
```


*My boss said i can use our aggregated data, internal ID's, first names, no identifying info. same with account and employer info.*


## who our union represents:
**Cleaners, janitors, security guards, ushers, doormen, window cleaners**

## our most notable employers:
**World Trade Center, Empire State Building, Madison Square Garden, Yankee stadium , Barclays Center, Metropolitan opera house, Port Authority, CUNY Graduate Center**


jan 2023 to dec 2023


## steward info, leader points, and purple points, turnout points (CRM-prod)
2023 stewards

**SQL Query (CRMSQL):**
```{eval=FALSE, sql connection=CRMSQL} 
SELECT P.v3personID as 'Member ID',
D.divisionName AS 'Division',
DI.divisionTypeName AS "Division Type",
P.firstName,
PSR.personalActivityPoints as 'Activity Points',
PSR.totalLeadershipPoints as 'Leader Points',
PSR.ADFcardPoints as 'ADF Points',
PSR.membershipCardPoints as 'Member Card Points',
PSR.turnoutPoints as 'Turnout Points',
PSR.rewardType as 'Reward Type',
PSR.suggestedRewardLevel as 'Reward',
PSR.numofDaysSteward,
PSR.numOfDaysOnBrigades,
PSR.numOfDaysOnLOA,
a.V3accountID as 'Account Id'
from personsRoles PR
LEFT JOIN persons P on P.v3personID = PR.v3personID
LEFT JOIN accounts A on PR.v3accountID = A.v3accountID
LEFT JOIN jobs J ON P.primaryJobID = J.jobID
LEFT JOIN statuses S on S.statusID = J.statusID
LEFT JOIN accounts AC on AC.accountID = J.accountID  
LEFT JOIN divisions D on AC.divisionID = D.divisionID
LEFT JOIN divisionTypes DI ON AC.divisionTypeID = DI.divisionTypeID
LEFT JOIN locations L on AC.locationID = L.locationID
LEFT JOIN personsStewardRebates PSR on PSR.v3personID = P.v3personID
WHERE PR.roleTypeID = 1
AND (PR.statusID = 1 OR PR.dateEnd > '01-01-2023')
AND (A.dateStop > '01/01/2023' or A.dateStop is null)
AND PSR.rebateYear = 2023
AND D.divisionName NOT LIKE '%615%'
GROUP BY
P.v3personID,
D.divisionName,
AC.fieldRepresentative,
PSR.rewardType,
P.firstName,
P.lastName,
PSR.personalActivityPoints,
PSR.totalLeadershipPoints,
PSR.ADFcardPoints,
PSR.membershipCardPoints,
PSR.turnoutPoints,
PSR.rewardType,
PSR.suggestedRewardLevel,
PSR.numofDaysSteward,
PSR.numOfDaysOnBrigades,
PSR.numOfDaysOnLOA,
L.locationName,
a.V3accountID,
DI.divisionTypeName,
P.homePhone,
P.cellPhone,
P.email,
S.statusName 
ORDER BY
D.DivisionName,
AC.fieldRepresentative
```

**NY Commercial 2023 Steward Points, their attendance and attendance of people in their building** 
```{r}
StewardPoints <- read.csv("https://raw.githubusercontent.com/GuillermoCharlesSchneider/DATA-607/main/Final%20Project/Purple%20Points%20by%20steward%20(with%20their%20account%20numbers).csv")

#subset just the stewards in the NY Commercial division (no LOA complaints)
StewardPoints <- StewardPoints[which(StewardPoints$Division == 'NY Commercial'),]

StewardPoints$Account.Id <- as.numeric(StewardPoints$Account.Id)
```

## account info, complaints, complaint type? one hot encoding, claim types? (CRM-SQL)

**SQL query (CRMprod):**
``` {eval=FALSE, sql connection=CRMprod}
SELECT a.accountnumber,  c.seiu32bj_claimtypename, count(c.seiu32bj_claimtypename) as 'Number of Complaints'
FROM filteredseiu32bj_claim c
LEFT JOIN filteredIncident i on i.incidentid = c.seiu32bj_complaint 
LEFT JOIN FilteredAccount a ON i.seiu32bj_account = a.accountid
LEFT JOIN Filteredseiu32bj_steward s ON a.accountid = s.seiu32bj_stewardaccountlookup
WHERE c.createdon >= '2023-01-01 00:00:00.000' 
AND c.createdon < '2024-01-01 00:00:00.000' 
AND a.seiu32bj_districtname = 'New York Metro'
AND a.seiu32bj_division = 'NY Commercial'
AND i.customeridname != 'Test Member'
GROUP BY  a.accountnumber, c.seiu32bj_claimtypename
ORDER  by a.accountnumber DESC
```

**NY Commercial Total Complaints per account in 2023:**
```{r}
TotalComplaints <- read.csv("https://raw.githubusercontent.com/GuillermoCharlesSchneider/DATA-607/main/Final%20Project/Total%20Complaints%20Per%20Account.csv")

names(TotalComplaints)[1] <- "Account.Id"

#account id 
TotalComplaints$Account.Id <- as.numeric(TotalComplaints$Account.Id)

#remove complaints from EVENT, NULL, and NA job type workers
#TotalComplaints <- TotalComplaints[ -c(5,6,7) ]

```

**NY Commercial Count of Complaint types per account in 2023:**
```{r}
ComplaintTypes <- read.csv("https://raw.githubusercontent.com/GuillermoCharlesSchneider/DATA-607/main/Final%20Project/Complaint%20Types%20Per%20account%20(convert%20to%20one%20hot).csv")

ComplaintTypes <- ComplaintTypes[which(ComplaintTypes$seiu32bj_claimtypename != 'Leave of Absence'),]
```


**NY Commercial Count of Members per account in 2023:** *i filtered out the recent 2024 hires, and made sure to include members who left in 2024, but were on the roster in 2023, i think ultimately the number is very close to just pulling the current 2024 roster today, due to most places total job count staying relatively stable*

**SQL Query (CRMprod)**
```{eval=FALSE, sql connection=}
SELECT DISTINCT a.V3accountID as 'Account.Id', count(a.V3accountID) as 'Members'
FROM [dbo].[jobs] j
LEFT JOIN accounts a on j.accountID = a.accountID
WHERE a.divisionID = 9
AND j.dateHired < '2024-01-01 00:00:00.000' 
AND (j.statusID = 1 or (j.dateTerminated > '2024-01-01 00:00:00.000')) 
AND (A.dateStop > '01/01/2023' or A.dateStop is null)
GROUP by a.V3accountID
ORDER by  count(a.V3accountID) DESC
```

**MemberCountPerAccount**
```{r}
MemberCountPerAccount <- read.csv("https://raw.githubusercontent.com/GuillermoCharlesSchneider/DATA-607/main/Final%20Project/MembersPerAccount.csv")
```


**Cleaning:**
```{r}
#join in the total complaints for that account
MERGED <- StewardPoints %>% left_join(TotalComplaints)
MERGED <- MERGED %>% left_join(MemberCountPerAccount)

# NA's to 0
MERGED$FTComplaints[is.na(MERGED$FTComplaints)] <- 0
MERGED$PTComplaints[is.na(MERGED$PTComplaints)] <- 0
MERGED$TotalComplaints[is.na(MERGED$TotalComplaints)] <- 0
MERGED$FTAverageMembers[is.na(MERGED$FTAverageMembers)] <- 0
MERGED$PTAverageMembers[is.na(MERGED$PTAverageMembers)] <- 0
MERGED$FTMembers[is.na(MERGED$PTMembers)] <- 0
MERGED$PTMembers[is.na(MERGED$PTMembers)] <- 0
MERGED$TotalAverageMembers[is.na(MERGED$TotalAverageMembers)] <- 0
MERGED$TotalMembers[is.na(MERGED$TotalMembers)] <- 0

# removing the acccounts with 0 members. my guess is most of these are probably flipped accounts, another company took them over mid 2023, those members still exist but in a new account for a new employer, same steward
MERGED <- MERGED[which(MERGED$TotalMembers != 0),]

#keep just the year-long stewards
MERGED <- MERGED[which(MERGED$numofDaysSteward == 365),]

#removed the EVT workers. only 4 accounts, huge amounts of rotating temp workers, lots of complaints, no long relationship w/ their steward
#changed to removing the Event workers in the SQL query
#MERGED <- MERGED[which(MERGED$EVTMembers == 0),]

#add a new column of complaint rate, complaints / total members
#MERGED <- MERGED
MERGED$ComplaintRate <- MERGED$TotalComplaints / MERGED$TotalAverageMembers * 100

```

**Total AVERAGE Member count variable:**
This is to account for turnover through the year. Take all the members who worked at location in 2023, Sum the Number of days worked by each employee, and divide by 365. This gives you a approximate "average roster size" for throughout all of 2023. Each member needs to be included, because each member has a opportunity to file a complaint while they work and are represented by the union, regardless of how short their work length was

**OVERALL leadership points: Combining stewards by account. I added together the stewards for each account. bigger accounts often have multiple stewards. ** 
```{r}
GroupedStewards <- MERGED %>% group_by(Account.Id, FTComplaints,PTComplaints,TotalComplaints, FTAverageMembers, PTAverageMembers,TotalAverageMembers, FTMembers, PTMembers,TotalMembers,ComplaintRate) %>% summarise(totalActivityPoints = sum(Activity.Points),totalTurnoutPoints = sum(Turnout.Points) ,.groups = 'drop')
                                                                                                         
GroupedStewards
```



## Graphs:
**There are 4 big accounts that are outside 100 members, but most of the accounts fall between this range i set up to easier visualize**
```{r}
ggplot(MERGED, aes(x=TotalAverageMembers, y=TotalComplaints)) + 
    geom_point(alpha=0.7)+
  xlim(0,100)+
  ylim(0,75)+
  geom_smooth(method=lm, color="lightblue", fill="#69b3a2", se=TRUE) 
```


```{r}
ggplot(MERGED, aes(x=TotalAverageMembers, y=ComplaintRate)) + 
    geom_point(alpha=0.7)+
  ylim(0,200)+
  xlim(1,100)
  geom_smooth(method=lm , color="lightblue", fill="#69b3a2", se=TRUE) 
```

```{r}
CL1 <- ggplot(GroupedStewards, aes(x=totalActivityPoints, y=ComplaintRate, size = TotalAverageMembers)) + 
    geom_point(alpha=0.7) +
  ylim(0,200)

CL2 <- ggplot(GroupedStewards, aes(x=totalTurnoutPoints, y=ComplaintRate, size = TotalAverageMembers)) + 
    geom_point(alpha=0.7)+
  ylim(0,200)

plot_grid(CL1, CL2, labels = c('A', 'B'), label_size = 12)
```
```{r}
ggplot(MERGED, aes(x=Activity.Points, y=ComplaintRate, size =TotalAverageMembers)) + 
    geom_point(alpha=0.7)+
  ylim(0,200)+
  geom_smooth() 
```
```{r}
ggplot(MERGED, aes(x=Turnout.Points, y=ComplaintRate, size=TotalAverageMembers)) + 
    geom_point(alpha=0.7)+
  ylim(0,200)+
  geom_smooth() 
```





## machine learning -- decision tree

*https://www.modernstatisticswithr.com/mlchapter.html#mlmethods*

```{r}
tc <- trainControl(method = "LOOCV")

m <- train(ComplaintRate ~ Activity.Points + Turnout.Points + FTAverageMembers + PTAverageMembers + TotalAverageMembers,
           data = MERGED,
           trControl = tc,
           method = "rpart",
           tuneGrid = expand.grid(cp = 0))

m2 <- train(ComplaintRate ~ totalActivityPoints + totalTurnoutPoints + FTAverageMembers + PTAverageMembers + TotalAverageMembers,
           data = GroupedStewards,
           trControl = tc,
           method = "rpart",
           tuneGrid = expand.grid(cp = 0))

```


```{r}
m
```


```{r}
prp(m$finalModel)

prp(m$finalModel,
    box.palette = "BuRd",
    shadow.col = "gray",
    nn = TRUE,
    type =3,
    extra = 1,
    cex = 0.5,
    compress=TRUE,
    fallen.leaves = TRUE)
```

**Trying instead with grouped stewards**
```{r}
prp(m2$finalModel)

prp(m2$finalModel,
    box.palette = "BuRd",
    shadow.col = "gray",
    nn = TRUE,
    type =3,
    extra = 1,
    cex = 0.5,
    compress=TRUE,
    fallen.leaves = TRUE)
```
## ACTUAL vs PREDICTED
```{r}
actualAndPredictedData = data.frame(Account.Id = MERGED$Account.Id, StewardName = MERGED$firstName, Steward.Id = MERGED$Member.ID, actualValue = MERGED$ComplaintRate, 
                                    predictedValue = predict(m,MERGED))

ggplot(actualAndPredictedData,aes(x = actualValue, y = predictedValue)) +
ylim(0,200)+
xlim(0,250)+
geom_point()

#write.csv(actualAndPredictedData, "actualAndPredictedData.csv")

```


